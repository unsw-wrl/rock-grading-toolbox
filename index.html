<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Rock Grading Tool</title>
  <style>
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 24px auto;
      padding: 0 16px;
      line-height: 1.4;
    }

    .row {
      margin-bottom: 10px;
    }

    .controls {
      border: 1px solid #dcdcdc;
      border-radius: 8px;
      padding: 14px;
      margin-bottom: 12px;
      background: #fafafa;
    }

    .progress-wrap {
      margin-top: 12px;
      display: none;
    }

    .progress-label {
      font-size: 13px;
      margin-bottom: 6px;
      color: #333;
    }

    .progress-track {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: #e6e6e6;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #198754, #3bb273);
      transition: width 0.2s ease;
    }

    #output {
      margin-top: 14px;
      white-space: pre-wrap;
      border: 1px solid #dcdcdc;
      border-radius: 8px;
      padding: 12px;
      min-height: 80px;
      background: #fff;
    }

    .error {
      color: #b02a37;
    }

    .manual-adds {
      margin-top: 14px;
      border: 1px dashed #c8c8c8;
      border-radius: 8px;
      padding: 10px;
      background: #ffffff;
    }

    .manual-adds h3 {
      margin: 0 0 8px;
      font-size: 15px;
    }

    .manual-item {
      border: 1px solid #e2e2e2;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
      background: #fafafa;
    }

    .manual-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 8px;
      align-items: end;
    }

    .manual-grid label {
      font-size: 12px;
      color: #444;
    }

    .manual-grid input {
      width: 100%;
      box-sizing: border-box;
    }

    .plots {
      margin-top: 14px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .plot-card {
      border: 1px solid #dcdcdc;
      border-radius: 8px;
      padding: 8px;
      background: #fff;
      min-height: 420px;
    }
  </style>
</head>
<body>

<h2>Rock Grading Tool</h2>

<div class="controls">
  <div class="row">
    <label>Upload CSV 1:</label>
    <input type="file" id="file1">
  </div>
  <div class="row">
    <label>Total Mass (kg):</label>
    <input type="number" id="mass1" value="20">
  </div>
  <div class="row">
    <label>Shape Factor:</label>
    <input type="number" id="shape1" value="0.9" step="0.01">
  </div>

  <div class="row" style="margin-top: 16px;">
    <label>Upload CSV 2:</label>
    <input type="file" id="file2">
  </div>
  <div class="row">
    <label>Total Mass (kg):</label>
    <input type="number" id="mass2" value="20">
  </div>
  <div class="row">
    <label>Shape Factor:</label>
    <input type="number" id="shape2" value="0.9" step="0.01">
  </div>

  <div class="manual-adds">
    <h3>Manual Dn Additions (Optional)</h3>
    <div id="manualAddsList"></div>
    <button type="button" id="addManualBtn" onclick="addManualAddRow()">Add Manual Range</button>
  </div>

  <button id="runButton" onclick="runPython()">Run Model</button>
  <input type="file" id="appPyFile" accept=".py,text/x-python" style="display:none">

  <div class="progress-wrap" id="progressWrap">
    <div class="progress-label" id="progressLabel">Starting...</div>
    <div class="progress-track">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>
</div>

<div id="output"></div>
<div class="plots">
  <div id="massPlot" class="plot-card"></div>
  <div id="dnPlot" class="plot-card"></div>
</div>

<script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<script>
let pyodide;
let appSourceCache = null;
let manualAddCounter = 0;
const pyodideReadyPromise = initPyodide();

async function initPyodide() {
  setProgress(5, "Loading Python runtime...");
  pyodide = await loadPyodide();

  setProgress(25, "Loading Python packages (first run can take a while)...");
  await pyodide.loadPackage(["numpy", "pandas", "matplotlib"]);

  setProgress(100, "Python ready");
  hideProgressSoon();
}

function pickLocalAppPyFile() {
  return new Promise((resolve, reject) => {
    const input = document.getElementById("appPyFile");
    input.value = "";
    input.onchange = async () => {
      const f = input.files && input.files[0];
      if (!f) {
        reject(new Error("Local mode needs app.py selected once per page load."));
        return;
      }
      try {
        resolve(await f.text());
      } catch (e) {
        reject(new Error("Could not read selected app.py file."));
      }
    };
    input.click();
  });
}

async function ensureAppModuleLoaded() {
  if (appSourceCache) {
    pyodide.FS.writeFile("app.py", appSourceCache);
    return;
  }

  try {
    const resp = await fetch("./app.py", { cache: "no-store" });
    if (!resp.ok) {
      throw new Error(`HTTP ${resp.status}`);
    }
    appSourceCache = await resp.text();
  } catch (e) {
    if (window.location.protocol === "file:") {
      setProgress(45, "Select local app.py...");
      appSourceCache = await pickLocalAppPyFile();
    } else {
      throw new Error("Could not load app.py from site root.");
    }
  }

  pyodide.FS.writeFile("app.py", appSourceCache);
}

function setProgress(percent, label) {
  const wrap = document.getElementById("progressWrap");
  const fill = document.getElementById("progressFill");
  const text = document.getElementById("progressLabel");
  wrap.style.display = "block";
  fill.style.width = `${percent}%`;
  text.textContent = label;
}

function hideProgressSoon() {
  setTimeout(() => {
    const wrap = document.getElementById("progressWrap");
    wrap.style.display = "none";
  }, 600);
}

function renderResult(result) {
  const out = document.getElementById("output");
  const massCount = result.mass_curve ? result.mass_curve.length : 0;
  const dnCount = result.dn_curve ? result.dn_curve.length : 0;

  let text = "Model completed.\n";
  text += `Sources: ${result.sources.join(", ")}\n`;
  text += `Mass curve points: ${massCount}\n`;
  text += `Dn curve points: ${dnCount}\n`;

  if (result.target_mix_fit_mse !== undefined) {
    text += `Target mix fit MSE: ${result.target_mix_fit_mse}\n`;
    text += "Target mix weights:\n";
    for (const [name, weight] of Object.entries(result.target_mix_weights || {})) {
      text += `  ${name}: ${(100 * weight).toFixed(2)}%\n`;
    }
  }

  out.classList.remove("error");
  out.textContent = text;
  renderPlots(result);
}

function addManualAddRow(prefill = null) {
  manualAddCounter += 1;
  const id = `manual_add_${manualAddCounter}`;
  const wrap = document.createElement("div");
  wrap.className = "manual-item";
  wrap.dataset.manualId = id;

  const d = prefill || {};
  wrap.innerHTML = `
    <div class="manual-grid">
      <div><label>Label</label><input type="text" class="manual-label" value="${d.label || id}"></div>
      <div><label>Total Mass (kg)</label><input type="number" class="manual-total" min="0" step="any" value="${d.total_mass_kg ?? ""}"></div>
      <div><label>Dn Min (mm)</label><input type="number" class="manual-dn-min" min="0" step="any" value="${d.dn_min_mm ?? ""}"></div>
      <div><label>Dn Max (mm)</label><input type="number" class="manual-dn-max" min="0" step="any" value="${d.dn_max_mm ?? ""}"></div>
      <div><label>Shape Factor</label><input type="number" class="manual-shape" min="0" step="any" value="${d.shape_factor ?? 0.9}"></div>
      <div><label>Points</label><input type="number" class="manual-n-points" min="2" step="1" value="${d.n_points ?? 30}"></div>
      <div><button type="button" class="manual-remove">Remove</button></div>
    </div>
  `;

  wrap.querySelector(".manual-remove").addEventListener("click", () => {
    wrap.remove();
  });

  document.getElementById("manualAddsList").appendChild(wrap);
}

function collectManualAdds() {
  const rows = Array.from(document.querySelectorAll("#manualAddsList .manual-item"));
  const out = {};

  for (let i = 0; i < rows.length; i += 1) {
    const row = rows[i];
    const rowNum = i + 1;
    const labelRaw = row.querySelector(".manual-label").value.trim();
    const totalRaw = row.querySelector(".manual-total").value;
    const dnMinRaw = row.querySelector(".manual-dn-min").value;
    const dnMaxRaw = row.querySelector(".manual-dn-max").value;
    const shapeRaw = row.querySelector(".manual-shape").value;
    const pointsRaw = row.querySelector(".manual-n-points").value;

    const allEmpty = !labelRaw && !totalRaw && !dnMinRaw && !dnMaxRaw && !shapeRaw && !pointsRaw;
    if (allEmpty) {
      continue;
    }

    const totalMassKg = parseFloat(totalRaw);
    const dnMinMm = parseFloat(dnMinRaw);
    const dnMaxMm = parseFloat(dnMaxRaw);
    const shapeFactor = parseFloat(shapeRaw);
    const nPoints = parseInt(pointsRaw || "30", 10);

    if (!Number.isFinite(totalMassKg) || totalMassKg <= 0) {
      throw new Error(`Manual add row ${rowNum}: total mass must be > 0.`);
    }
    if (!Number.isFinite(dnMinMm) || dnMinMm <= 0) {
      throw new Error(`Manual add row ${rowNum}: Dn min must be > 0.`);
    }
    if (!Number.isFinite(dnMaxMm) || dnMaxMm <= 0) {
      throw new Error(`Manual add row ${rowNum}: Dn max must be > 0.`);
    }
    if (!Number.isFinite(shapeFactor) || shapeFactor <= 0) {
      throw new Error(`Manual add row ${rowNum}: shape factor must be > 0.`);
    }
    if (!Number.isFinite(nPoints) || nPoints < 2) {
      throw new Error(`Manual add row ${rowNum}: points must be at least 2.`);
    }

    let label = labelRaw || `manual_${rowNum}`;
    let suffix = 2;
    while (Object.prototype.hasOwnProperty.call(out, label)) {
      label = `${labelRaw || `manual_${rowNum}`}_${suffix}`;
      suffix += 1;
    }

    out[label] = {
      total_mass_kg: totalMassKg,
      dn_min_mm: dnMinMm,
      dn_max_mm: dnMaxMm,
      shape_factor: shapeFactor,
      n_points: nPoints
    };
  }

  return out;
}

function renderPlots(result) {
  if (typeof Plotly === "undefined") {
    return;
  }

  const sourcePalette = [
    "rgba(31,119,180,0.45)",
    "rgba(255,127,14,0.45)",
    "rgba(44,160,44,0.45)",
    "rgba(214,39,40,0.45)",
    "rgba(148,103,189,0.45)",
    "rgba(140,86,75,0.45)",
    "rgba(227,119,194,0.45)",
    "rgba(127,127,127,0.45)",
    "rgba(188,189,34,0.45)",
    "rgba(23,190,207,0.45)"
  ];

  const massX = (result.mass_curve || []).map((p) => p.mass_g);
  const massY = (result.mass_curve || []).map((p) => p.pct_passing);
  const dnX = (result.dn_curve || []).map((p) => p.Dn_mm);
  const dnY = (result.dn_curve || []).map((p) => p.pct_passing);

  const sourceMassTraces = Object.entries(result.source_mass_curves || {}).map(
    ([label, points], idx) => ({
      x: points.map((p) => p.mass_g),
      y: points.map((p) => p.pct_passing),
      type: "scatter",
      mode: "lines",
      name: label,
      line: { color: sourcePalette[idx % sourcePalette.length], width: 1.6 }
    })
  );

  Plotly.newPlot(
    "massPlot",
    [
      ...sourceMassTraces,
      {
        x: massX,
        y: massY,
        type: "scatter",
        mode: "lines",
        name: "Combined",
        line: { color: "#000000", width: 3 }
      }
    ],
    {
      title: "Mass Distribution",
      xaxis: { title: "Mass (g)" },
      yaxis: { title: "Percentage Passing (%)", range: [0, 100] },
      margin: { l: 55, r: 20, t: 45, b: 50 }
    },
    { responsive: true, displaylogo: false }
  );

  const sourceDnTraces = Object.entries(result.source_dn_curves || {}).map(
    ([label, points], idx) => ({
      x: points.map((p) => p.Dn_mm),
      y: points.map((p) => p.pct_passing),
      type: "scatter",
      mode: "lines",
      name: label,
      line: { color: sourcePalette[idx % sourcePalette.length], width: 1.6 }
    })
  );

  const dnTraces = [
    ...sourceDnTraces,
    {
      x: dnX,
      y: dnY,
      type: "scatter",
      mode: "lines",
      name: "Combined",
      line: { color: "#000000", width: 3 }
    }
  ];

  if (result.final_mix_dn_curve) {
    dnTraces.push({
      x: result.final_mix_dn_curve.map((p) => p.Dn_mm),
      y: result.final_mix_dn_curve.map((p) => p.pct_passing),
      type: "scatter",
      mode: "lines",
      name: "Final Mix",
      line: { color: "#2ca02c", width: 2.5, dash: "dash" }
    });
  }

  Plotly.newPlot(
    "dnPlot",
    dnTraces,
    {
      title: "Nominal Diameter Distribution",
      xaxis: { title: "Equivalent Nominal Diameter Dn (mm)" },
      yaxis: { title: "Percentage Passing (%)", range: [0, 100] },
      margin: { l: 55, r: 20, t: 45, b: 50 }
    },
    { responsive: true, displaylogo: false }
  );
}

async function runPython() {
  const runButton = document.getElementById("runButton");
  const out = document.getElementById("output");

  try {
    out.classList.remove("error");
    out.textContent = "";

    const file1 = document.getElementById("file1").files[0];
    const file2 = document.getElementById("file2").files[0];

    runButton.disabled = true;

    setProgress(10, "Waiting for Python to be ready...");
    await pyodideReadyPromise;

    setProgress(35, "Loading model code...");
    await ensureAppModuleLoaded();

    setProgress(50, "Reading inputs...");

    const mass1 = parseFloat(document.getElementById("mass1").value);
    const mass2 = parseFloat(document.getElementById("mass2").value);
    const shape1 = parseFloat(document.getElementById("shape1").value);
    const shape2 = parseFloat(document.getElementById("shape2").value);
    const manualAdds = collectManualAdds();

    const distributions = {};
    if (file1) {
      const text1 = await file1.text();
      distributions.dist1 = {
        csv_text: text1,
        total_mass_kg: mass1,
        shape_factor: shape1
      };
    }
    if (file2) {
      const text2 = await file2.text();
      distributions.dist2 = {
        csv_text: text2,
        total_mass_kg: mass2,
        shape_factor: shape2
      };
    }

    if (Object.keys(distributions).length === 0 && Object.keys(manualAdds).length === 0) {
      throw new Error("Provide at least one CSV distribution or one manual Dn addition.");
    }

    const config = {
      distributions,
      manual_adds: manualAdds,
      do_plots: false
    };

    setProgress(65, "Running model...");
    pyodide.globals.set("config_js", config);

    await pyodide.runPythonAsync(`
import json
from app import run_model

config = config_js.to_py()
result = run_model(config)
result_json = json.dumps(result)
    `);

    setProgress(90, "Formatting results...");
    const resultJson = pyodide.globals.get("result_json");
    const result = JSON.parse(resultJson);

    renderResult(result);
    setProgress(100, "Done");
    hideProgressSoon();
  } catch (err) {
    out.classList.add("error");
    out.textContent = `Error: ${err.message || err}`;
    if (typeof Plotly !== "undefined") {
      Plotly.purge("massPlot");
      Plotly.purge("dnPlot");
    }
    setProgress(100, "Run failed");
  } finally {
    runButton.disabled = false;
  }
}
</script>

</body>
</html>
